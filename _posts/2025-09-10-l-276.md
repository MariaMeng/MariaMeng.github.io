---
layout: post
title: "LeetCode 276. 栅栏涂色 题解"
date: 2025-09-10 12:31:00 +0800
categories: leetcode
---

> 思路

dp[i][0]: 第i位置与第i-1位置相同时,方案个数
dp[i][1]: 第i位置与第i-1位置不同时, 方案个数



状态转移方程:

如果相同时, 那么前2个位置只能是不同的情况, XAA, 分别表示第i - 2个位置是X, 第i -1 个位置是 A, 第 i 个位置是A的情况, 
那么X一定不是A, 并且i位置一定是A, 因为i-1位置已经固定了, 第i个位置不可能再有其他选择的情况, 只能与i - 1的数值保持一致
所以原问题一一定是子问题i-1和i-2不同时的方案个数
```text
dp[i][0] = dp[i- 1][1]
```

如果不同时, 那么前2个位置可能相同, 也可能不同, XAB, 分别表示第i - 2个位置是X, 第i -1 个位置是 A, 第 i 个位置是B的情况,
那么X可以是A, 也可以是B, 并且第i 个位置, 可以有k - 1种选择，只要保证与i - 1不相同就行

```text
dp[i][1] = (dp[i - 1][0] + dp[io - 1][1]) * (k - 1)
```


所以最终的求解D(i) = dp[i][0] + dp[i][1]就是答案

代码:
```java
class Solution {
    public int numWays(int n, int k) {
        if (n == 1) return k;
        int[][] dp = new int[n + 1][2];
        
        dp[1][0] = 0;
        dp[1][1] = k;

        for (int i = 2; i <= n; i++) {
            dp[i][0] = dp[i - 1][1];
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) * (k - 1);
        }
        return dp[n][0] + dp[n][1]; 
    }
}
```

复杂度:
- 时间: O(n)
- 空间: O(n)

空间复杂度还可以再优化, 因为目前状态转移方程中, 第i 状态的数值仅仅依赖i - 1状态的数值, 所以 i- 2之前的状态不需要存储

```java
class Solution {
  public int numWays(int n, int k) {
    if (n == 1) return k;
    int same = 0;
    int diff = k;

    for (int i = 2; i <= n; i++) {
      int preSame = same;

      same = diff;
      diff = (preSame + diff) * (k - 1);

    }

    return same + diff;
  }
}
```
- 时间: O(n)
- 空间 O(1)

