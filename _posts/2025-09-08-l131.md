---
layout: post
title: "LeetCode 131. 分割回文串 题解"
date: 2025-09-08 18:47:00 +0800
categories: leetcode
---

> 思路

动态规划
[L241](./2025-09-08-diff-ways-to-compute.md)
参考这个思路, 动态规划
dp[i][j] 为i到j的解集合, 可以规约成dp[i][k] 和dp[k + 1][j], 如果两个子串为回文的话

> 代码

```java
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

class Solution {
    
    
    public List<List<String>> partition(String s) {
        int n = s.length();
        // dp[l][r]：存储 s[l..r] 的所有回文分割方案（去重后）
        List<List<String>>[][] dp = new List[n][n];

        boolean[][] palin = new boolean[n][n];

        // 1. 初始化：长度为 1 的子串（无重复可能，直接用 ArrayList）
        for (int l = 0; l < n; l++) {
            dp[l][l] = new ArrayList<>();
            List<String> single = new ArrayList<>();
            single.add(s.substring(l, l + 1));
            dp[l][l].add(single);
        }

        // 2. 状态转移：按子串长度从 2 到 n 递增
        for (int len = 2; len <= n; len++) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                // 用 LinkedHashSet 存储方案，自动去重并保持顺序
                Set<List<String>> schemeSet = new LinkedHashSet<>();

                // 情况 1：枚举所有分割点，组合左右子问题的方案
                for (int k = l; k < r; k++) {
                    List<List<String>> leftSchemes = dp[l][k];
                    List<List<String>> rightSchemes = dp[k + 1][r];

                    // 笛卡尔积组合：左方案的每个元素 + 右方案的每个元素
                    for (List<String> left : leftSchemes) {
                        for (List<String> right : rightSchemes) {
                            List<String> combined = new ArrayList<>(left);
                            combined.addAll(right);
                            schemeSet.add(combined); // 重复方案会被自动过滤
                        }
                    }
                }

                // 情况 2：如果整个子串是回文，添加单独的方案
                if (isPalindrom(s, l, r, palin)) {
                    List<String> wholePalindrome = new ArrayList<>();
                    wholePalindrome.add(s.substring(l, r + 1));
                    schemeSet.add(wholePalindrome);
                }

                // 将去重后的方案转成 ArrayList 存入 dp[l][r]
                dp[l][r] = new ArrayList<>(schemeSet);
            }
        }

        return dp[0][n - 1];
    }

    // 验证 s[l..r] 是否为回文（闭区间，l <= r）
    private boolean isPalindrom(String s, int l, int r, boolean[][] palin) {
        if (palin[l][r]) {
            return true;
        }
        
        while (l < r) {
            if (s.charAt(l++) != s.charAt(r--)) {
                return false;
            }
        }

        palin[l][r] = true;
        return true;
    }
}
```

> 复杂度

- 时间: O(n ^ 3)
- 空间: O(n ^ 2)