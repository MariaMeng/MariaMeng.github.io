---
layout: post
title: "LeetCode 213. 打家劫舍 II 题解"
date: 2025-09-08 18:47:00 +0800
categories: leetcode
---

> 思路

这道题目就是在198 的基础之上写的


198的dp数组的含义:
```text
dp[i]: 前i个元素的最大和
- 情况1: 不选, dp[i] = dp[i -1]
- 情况2: 选, dp[i] = nums[i - 1] + dp[i - 2]

dp[i] = max(dp[i - 1], nums[i - 1] + dp[i - 2])
```

这道题, 需要要求首位两个元素不能同时选取,dp数组的含义:

```text
dp[i][0]: 第一个元素不选, 前i个元素的最大和
dp[i][1]: 第一个元素选, 前i个元素的最大和

dp[i][0] = Math.max(dp[i - 1][0], nums[i - 1] + dp[i - 2][0]);
dp[i][1] 分两种情况:
- 情况1: i < n, dp[i][1] = Math.max(dp[i - 1][1], nums[i - 1] + dp[i - 2][1]);
- 情况2: i == n, dp[i][1] = dp[i - 1][1];
```
返回值就是dp[n][0]和dp[n][1]的最大值

代码:
```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[][] dp = new int [n + 1][2];

        dp[1][0] = 0;
        dp[1][1] = nums[0];

        for (int i = 2; i <= n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], nums[i - 1] + dp[i - 2][0]);
            if (i < n) {
                dp[i][1] = Math.max(dp[i - 1][1], nums[i - 1] + dp[i - 2][1]);
            } else {
                dp[i][1] = dp[i - 1][1];
            }
        }

        return Math.max(dp[n][0], dp[n][1]);
    }
}
```
复杂度：
- 时间：O(n)
- 空间: O(n)

空间也可以再优化, 当前状态仅仅依赖前一个和前2个状态的数值, 可以优化到O(1)